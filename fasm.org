# -*- mode: org; -*-
#+STARTUP: showall indent hidestars

#+TITLE: Forth Assembler

* Intro

Эта часть работы является необязательной, чтобы весь проект заработал. Но она важна для производительности и Just-In-Time компиляции, поэтому форт-ассемблер, способный производить на лету код для целевой архитектуры может быть очень полезным. Для каждой из целевых архитектур он будет своим, поэтому мы должны иметь возмоность подключать и отключать словари.

* Background

Традиционно в программе на ассемблере имеется операции, которые добавляют байты в ассемблируемую программу и разрешают метки, что может привести к изменению байтов, которые уже были ассемблированы. Самая простая операция - это что-то вроде db:

#+BEGIN_SRC asm
  db 0x1a  ; clear screen
#+END_SRC

Это добавляет байт 0x1a к текущему указателю (который называется "$" в Intel-синтаксисе ассемблера, или "." в синтаксисе AT&T gas) и перемещает текущий указатель на один байт вперед.

Напротив, при расчете RPN (обратной польской нотации) у нас есть последовательность операций. которые добавляют числа в стек, перемещая указатель стека. Если ваш RPN вычислитель находится в шестнадцатеричном режиме и обрабатывает операцию "1A" затем он добавляет число "0x1a" к текущему указателю стека и перемещает текущий указатель на один элемент стека.

Между этими двумя операциями имеется очевидное сходство. Но добавить программируемость в калькулятор RPN очень просто. Что произойдет, если мы попытаемся постепенно добавить RPN вычислительные способности на минимальном ассемблере? Можем ли мы положить весь наборы команд в библиотеки макросов, если мы просто объединим стек операндов с пространством памяти?

Интелловский ассемблер намного проще читать (и писать) в восьмеричной системе, так как операнды как правило состоят из опкода, байта mod/rm неопосредственного значения и других компонентов, которые могут быть объединены операций "или", которая будет удобна для сборки команд из отдельных компонентов, лежащих на стеке.

Очень просто добавить операцию RPN, например |, который заменяет последние два выданных байта их побитовым ИЛИ

Следующий очевидный шаг в направлении настоящего ассемблера с мнемониками - это достаточная макросистема, позволяющая записать что-то вроде

#+BEGIN_SRC forth
  mov1 %ax %bp rr | | ,
#+END_SRC

ля чего требуется только уметь определять слова которые расширяются до чисел, например EQU.

И после этого мы, вероятно, хотим что-то, что позволит писать

#+BEGIN_SRC forth
  %ax %bp mov-rr ,
#+END_SRC

который требует mov-rr иметь возможность каким-то образом вставить байт инструкции перед его аргументами. Мы хотели бы иметь возможность определить это, по крайней мере, как что-то вроде

#+BEGIN_SRC forth
  : mov-rr
      swap 3 << |
      300 |
      211 swap
  ;
#+END_SRC

и возможно лучше как-то вроде

#+BEGIN_SRC forth
  : mov-rr { src dest }
      211 300 src 3 << |
      dest |
      ; .
#+END_SRC

Готовое решение для такого рода вещей - это indirect-threaded Forth.

Как минимум, он имеет стек операндов (в данном случае случае это дублирует генерируемый код, хотя и с одним словом на элемент, а не по одному байту на элемент), стек возврата, чтобы подпрограммы смогли вызывать другие подпрограммы и словарь.

Некоторые подпрограммы в словаре, например "|" выше, реализуются машинным кодом. Обычно он также имеет "@" и "!" операции по доступу к память. Имеется возможность добавления новых элементов в словарь, который можно освободить только в порядке LIFO.

И довольно просто увидеть, как можно накапливать метки в словаре в виде связанных списков указателей на растущего кода, пропуская указатель стека операндов по желанию, чтобы помещать код в разные сегменты и другие вещи вы можно хотеть сделать на ассемблере.

И как только мы договорились о наличии гибкого транслятора, мы можем реализовать основные функции ассемблера в INTERPRET, который позволит нам засунуть основные функции ассемблера в библиотеки макросов, которые загружаются когда мы запускаем соответствующий словарь
