# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

AASM - Abstract Assembler

* Intro

Я буду использовать emacs-lisp, чтобы сформировать некоторый
"промежуточный ассемблер", который может быть скомпилирован
под любую архитектуру, включая, но не ограничиваясь:
- 8-разрядный AVR
- 16-разрядный x86
- 32-разрядный x86
- 32-разрядный ARM
- 64-разрядный x86_64
- WebAssembly VM
- ...

Текущее состояние - Proof-of-Concept, требуется показать
способность решения компилировать какой-то минимальный код,
не зависящий от разрядности используемой архитектуры.

* Motivation

Стараясь следовать идее минимализма, но не в ущерб определенности, я
предпочел бы иметь минимальный набор самых низкоуровневых машинных
команд, чтобы на нем построить все остальное. Такой минимальный набор
нужен для каждой целевой архитектуры, и он должен быть очень гибким,
чтобы работать на процессорах с разной длиной машинного слова и разным
набором команд.

Однако, не хотелось бы полностью писать этот архитектурно-зависимый слой,
потому что у всех архитектур есть нечто общее: несколько регистров и
обращения к памяти. Регистры могут иметь разную рязрядность (8 бит - 64
бита), на обращения к памяти могут накладывать ограничения (ARM), но
общего достаточно много.

Также хотелось бы, иметь полный контроль за тем, как будут
ассемблироваться команды - по этой причине не стоит делать этот слой с
использованием любого строннего компилятора, например компилятора си
(gcc) или ассемблера (nasm). У них могут быть различия в работе от версии
к версии или от платформы к платформе и поэтому невозможно с уверенностью
контролировать процесс ассемблирования.

Это особенно важно, если когда-нибудь захочется применять
машинно-специфичные оптимизации, такие как распределение регистров, или
JIT-компиляцию.

Исходя из этого оптимальное решение - написать миниатюрный ассемблер
абстрактной машины, регистры и команды которой платформо-зависимы.

* Minimal machine architecture

Для функциионирования форт-машины требуется стек и
минимальный набор абстрактных регистров, которые позже будут
мапиться на реальные:
- %ACR - Accumilator Register (A)
- %BCR - Secondary Accumulator Register (B)
- %CCR - Third Accumulator Register (C)
- %DCR - Fourth Accumulator Register (D)
- %IPR - Instruction Pointer Register
- %RSR - Return Stack Register
- %DSR - Data Stack Register
- ...

Я буду использовать эти регистры в своем коде "абстрактного
ассемблера", а при компиляции они будут сопоставляться с
конкретными выбранными регистрами целевого ассемблера, при
этом целевой ассемблер я тоже напишу сам, чтобы иметь полную
свободу применения любых оптимизаций

* Minimal incoming code

Минимальный пример кода должен быть похож на код для gnu
assembler, на который я опираюсь и иметь:
- комментарии после команды до конца строки
- коментарии, занимающие всю строку
- некоторую поддержку отступов для удобства
- пустые строки
- двухоперандные команды перемещения значений (mov)
  - из регистра в регистр
  - из памяти в регистр
  - из регистра в память
- команды передачи управления (jmp)
  - прямой регистровый переход - jmp (reg)
- метки

такого минимального синтаксиса будет достаточно для написания
форт-машины, которая станет следующим уровнем языка. также такой подход
позволяет восстановить исходный код после разбора (для удобства отладки)

* Minimal code snippet

эти несколько строчек кода включают все вышеперечисленные варианты. они
поступают на вход процедуре разбора "абстрактного ассемблера"

#+name: min_aasm
#+begin_example asm

  # first COMMENT
    # COMMENT with indentation
      mov     %IPR, %ACR     # mov reg to reg
      mov     %IPR, %ACR
      mov     (%IPR), %ACR   # mov mem to reg
      mov     (%IPR), %ACR
      mov     %IPR, (%ACR)   # mov reg to mem
      mov     %IPR, (%ACR)
      jmp     %IRP           # jmp reg
      jmp     %IRP
      jmp     _label         # jmp label
      jmp     _label
  _label_with_comment:       # this is label
  _label:
#+END_EXAMPLE

* START Parsing of Abstract Assembler Code

Этот кусок кода разбирает минимальный сниппет кода на "абстрактном
ассемблере", чтобы получить из него список S-выражений

#+NAME: p_aasm
#+BEGIN_SRC elisp :noweb yes :tangle src/parse.el
  (setq *asmp* (make-hash-table :test 'eq))

  (hash-table-count *asmp*)

  <<parse_comment_line>>
  <<parse_const>>
  <<parse_mov_reg_to_reg>>
  <<parse_mov_reg_to_mem>>
  <<parse_add_const_to_reg>>
  <<parse_jmp_reg>>
  <<parse_jmp_reg_indirect>>
  <<parse_jmp_label>>
  <<parse_label>>
  <<parse_macro>>
  <<parse_endm>>

  (defun p-aasm (param)
    (block ram
      (if (or (string-equal "" param) (string-equal "" (string-trim-left param)))
          (return-from ram `(:empty)))
      (let* ((ident     (- (length param) (length (string-trim-left param))))
             (param     (string-trim-left param))
             (reg-size  4)
             (reg        "\\(%[a-zA-Z]\\{3\\}\\)")
             (case-fold-search nil))
        (maphash (lambda (key val)
                   (funcall val param))
                 ,*asmp*))))

  ;; (mapcar #'(lambda (in) (princ "\n") (prin1 in))
  ;;         (mapcar #'p-aasm
  ;;                 (split-string arg "\n" nil nil)))

  ;; (let ((arg "      add     $_WZ_, %IRP"))
  ;;   (mapcar #'(lambda (in) (princ "\n") (prin1 in))
  ;;           (mapcar #'p-aasm
  ;;                   (split-string arg "\n" nil nil))))
#+END_SRC

** Comment line

#+NAME: parse_comment_line
#+BEGIN_SRC elisp
  (setf (gethash :comment-line *asmp*)
        (lambda (param)
          (replace-regexp-in-string "^#\\(.*\\)"
                                    (lambda (in)
                                      (return-from ram `(comment-line ,in)))
                                    param)))
#+END_SRC

** Constants

.set someconst, someval

#+NAME: parse_const
#+BEGIN_SRC elisp
  (setf (gethash :const *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match "^\\.set\s+\\([_a-zA-Z]*\\)\s?,\s?\\([_a-zA-Z0-9]*\\)" param)
                 (return-from ram `(set-const :const ,(match-string 1 param)
                                              :val   ,(match-string 2 param)
                                              :rest  ,(match-string 3 param)
                                              :ident ,ident))))))

  ;; (let ((arg ".set F_LENMASK, 0x1f    # length mask"))
  ;;   (mapcar #'(lambda (in) (princ "\n") (prin1 in))
  ;;           (mapcar #'p-aasm
  ;;                   (split-string arg "\n" nil nil))))
#+END_SRC

** Mov register to register

#+NAME: parse_mov_reg_to_reg
#+BEGIN_SRC elisp
  (setf (gethash :mov-reg-to-reg *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match (concat "^mov\s*" reg "\s*,\s*" reg "\\(.*\\)") param)
                 (return-from ram `(mov_reg_to_reg :from  ,(match-string 1 param)
                                                   :to    ,(match-string 2 param)
                                                   :rest  ,(match-string 3 param)
                                                   :ident ,ident))))))
#+END_SRC

** Mov register to memory

#+NAME: parse_mov_reg_to_mem
#+BEGIN_SRC elisp
  (setf (gethash :mov-reg-to-mem *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match (concat "^mov\s*" reg "\s*,\s*(" reg ")\\(.*\\)") param)
                 (return-from ram `(mov_reg_to_mem :from  ,(match-string 1 param)
                                                   :to    ,(match-string 2 param)
                                                   :rest  ,(match-string 3 param)
                                                   :ident ,ident))))))
#+END_SRC

** Add constant to register

#+NAME: parse_add_const_to_reg
#+BEGIN_SRC elisp
  (setf (gethash :add-const-to-reg *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match (concat "^add\s+\\($[_A-Za-z]*\\)\s?,\s?" reg) param)
                 (return-from ram `(add_const_to_reg :const ,(match-string 1 param)
                                                     :to    ,(match-string 2 param)
                                                     :rest  ,(match-string 3 param)
                                                     :ident ,ident))))))
#+END_SRC

** Jump register

#+NAME: parse_jmp_reg
#+BEGIN_SRC elisp
  (setf (gethash :jmp-reg *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match (concat "^jmp\s*" reg "\\(.*\\)?$") param)
                 (return-from ram `(jmp_reg
                                    :to    ,(car (split-string (match-string 1 param)))
                                    :rest  ,(match-string 2 param)
                                    :ident ,ident))))))
#+END_SRC

** Jump register indirect

#+NAME: parse_jmp_reg_indirect
#+BEGIN_SRC elisp
  (setf (gethash :jmp-reg-indirect *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match (concat "^jmp\s*\\*(" reg ")\\(.*\\)?$") param)
                 (return-from ram `(jmp_reg_indirect
                                    :to    ,(car (split-string (match-string 1 param)))
                                    :rest  ,(match-string 2 param)
                                    :ident ,ident))))))
#+END_SRC

** Jump label

#+NAME: parse_jmp_label
#+BEGIN_SRC elisp
  (setf (gethash :jmp-label *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match
                  (concat "^jmp\s*" "\\([_a-zA-z]+\\)" "\s?\\(.*\\)?$") param)
                 (return-from ram  `(jmp_label
                                     :to    ,(car (split-string (match-string 1 param)))
                                     :rest  ,(match-string 2 param)
                                     :ident ,ident))))))
#+END_SRC

** Label

#+NAME: parse_label
#+BEGIN_SRC elisp
  (setf (gethash :label *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match
                  (concat "^\\([_a-zA-Z]+\\):" "\s?\\(.*\\)?$") param)
                 (return-from ram `(label
                                    :name  ,(car (split-string (match-string 1 param)))
                                    :rest  ,(match-string 2 param)
                                    :ident ,ident))))))
#+END_SRC

** Macro

#+NAME: parse_macro
#+BEGIN_SRC elisp
  (setf (gethash :macro *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match
                  (concat "^\\.macro\s*" "\\([_a-zA-z]+\\)" "\s?\\(.*\\)?$") param)
                 (return-from ram `(macro
                                    :name  ,(car (split-string (match-string 1 param)))
                                    :rest  ,(match-string 2 param)
                                    :ident ,ident))))))
#+END_SRC

** Endm

#+NAME: parse_endm
#+BEGIN_SRC elisp
  (setf (gethash :endm *asmp*)
        (lambda (param)
          (save-match-data
            (and (string-match
                  (concat "^\\.endm\s*" "\s?\\(.*\\)?$") param)
                 (return-from ram `(endm
                                    :rest  ,(match-string 2 param)
                                    :ident ,ident))))))
#+END_SRC

* GAS Producer

После парсинга входного ассемблерного кода мы получили
список S-exps, в котором каждый S-exp соответствует одной
строчке входного файла.

Мы должны уметь преобразовать его обратно для проверочных
целей.

Так как каждый из этих S-exps является вызовом функции, для
обратного преобразования нам нужно предоставить набор или
несколько наборов соответствующий функций.

Разные наборы могут понадобиться для выполнения
преобразований над кодом.

#+NAME: gas_producer
#+BEGIN_SRC elisp :var arg=p_aasm :results output
  (setq
   example
   '((set-const :const "_WZ_" :val "0x08" :rest nil :ident 0)
     (empty)
     (macro :name "NEXT" :rest "" :ident 0)
     (mov_reg_to_reg :from "%IRP" :to "%ACR" :rest "" :ident 4)
     (add_const_to_reg :const "$_WZ_" :to "%IRP" :rest "" :ident 4)
     (jmp_reg_indirect :to "%ACR" :rest "" :ident 4)
     (endm :rest "" :ident 0)
     (empty)))

  (defun gas-emit-empty (&rest rest)
    (format "\n"))

  (defun gas-emit-set-const (rest)
    (format "%s.set %s, %s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :const)
            (getf rest :val)
            (getf rest :rest)))

  (defun gas-emit-macro (rest)
    (format "%s.macro %s%s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :name)
            (getf rest :rest)))

  (defun gas-emit-endm (rest)
    (format "%s.endm%s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :rest)))

  (defun gas-emit-mov_reg_to_reg (rest)
    (format "%smov     %s, %s%s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :from)
            (getf rest :to)
            (getf rest :rest)))

  (defun gas-emit-add_const_to_reg (rest)
    (format "%sadd     %s, %s%s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :const)
            (getf rest :to)
            (getf rest :rest)))

  (defun gas-emit-jmp_reg_indirect (rest)
    (format "%sjmp     &(%s)%s\n"
            (make-string (getf rest :ident) ? )
            (getf rest :to)
            (getf rest :rest)))

  (defun gas-emit (in)
    (let ((func (car in))
          (args (cdr in)))
      (funcall (intern (concat "gas-emit-" (symbol-name func)))
               args)))

  (print (mapconcat (lambda (x) (gas-emit x)) example ""))
#+END_SRC

#+results: gas_producer
#+begin_example

".set _WZ_, 0x08

.macro NEXT
    mov     %IRP, %ACR
    add     $_WZ_, %IRP
    jmp     &(%ACR)
.endm

"
#+end_example

* START Opcode Producer

Каждая инструкция (почти) любого процессора имеет некоторый ~требуемый
эффект~, ради которого мы ее применяем. Обычно эффект выражается в
изменении регистров, памяти и флагов процессора.

Часто этот же требуемый эффект может быть достигнут комбинацией других
инструкций. Это дает нам возможность строить эквивалентные программы для
любых целей (оптимизация по скорости и размеру кода, обфускация, и.т.п)

Также у инструкции может быть ~побочный эффект~ (что еще изменяет эта
инструкция, кроме требуемого эффекта). На такие ~побочные эффекты~ можно
наложить ограничения, которые сработают при поиске и выборе нужных
инструкций, когда мы строим программу по эффектам.

Пользуясь данными об эффектах мы можем запустить солвер, чтобы построить
необходимую программу.

Для задачи построения виртуальной машины это не требуется, но если сейчас
заложить несколько вариантов достижения ~требуемых эффектов~, это может
пригодиться для генерализации подхода.

[TODO:gmm] - Написать солвер

** x86_64 Producer


Обычная инструкция на x86_64 имеет переменную длину (до 15 байт) и может
состоять из нескольких компонентов, порядок которых определен:
- Legacy prefixes (1-4 bytes, optional)
- Opcode with prefixes (1-4 bytes, required)
- ModR/M (1 byte, может отсутствовать, если опкод не имеет явных
  операндов)
- SIB (1 byte, для адресации операндов в памяти - может отсутствовать)
- Displacement (1, 2, 4 or 8 bytes, if required)
- Immediate (1, 2, 4 or 8 bytes, if required)

--skiped:https://www.youtube.com/watch?v=CUAXCeRjw3c:--

- Prefixes (REX, VEX : https://habr.com/ru/company/intel/blog/200598/)
  Использование REX позволяет расширить набор регистров
  r8-r15

- Links:
  - http://www.c-jump.com/CIS77/CPU/x86/X77_0060_mod_reg_r_m_byte.htm
  - https://stackoverflow.com/questions/15511482/x64-instruction-encoding-and-the-modrm-byte
  - https://sandpile.org/x86/opc_rm.htm

ModRM:
- mod[7:6] - 4 метода адресации
  - 00b Register indirect addressing mode or SIB with no
    displacement (when R/M=100b) or Displacement only
    addressing mode (when R/M=101b).
  - 01b One-byte signed displacement follows addressing mode
    byte(s).
  - 10b Four-byte signed displacement follows addressing mode byte(s).
  - 11b Register addressing mode.
- reg[.R, 5:3] - register-based operand or extend operation encoding
- r/m[.B, 2:0] – register or memory operand when combined with mod field.
- Addressing mode can include a following SIB byte {mod=00b,r/m=101b}

#+NAME: tbl_x86_reg_bits
| al ax eax          | 000 | nil |
| cl cx ecx          | 001 | nil |
| dl dx edx          | 010 | nil |
| bl bx ebx          | 011 | nil |
| ah sp esp          | 100 | nil |
| ch bp ebp          | 101 | nil |
| dh si esi          | 110 | nil |
| bh di edi          | 111 | nil |
| rax                | 000 |   1 |
| rcx                | 001 |   1 |
| rdx                | 010 |   1 |
| rbx                | 011 |   1 |
| rsp                | 100 |   1 |
| rbp                | 101 |   1 |
| rsi                | 110 |   1 |
| rdi                | 111 |   1 |
| bpl                | 101 |   1 |
| sil                | 110 |   1 |
| dil                | 111 |   1 |
| r8b r8w r8d r8     | 000 | nil |
| r9b r9w r9d r9     | 001 |   1 |
| r10b r10w r10d r10 | 010 |   1 |
| r11b r11w r11d r11 | 011 |   1 |
| r12b r12w r12d r12 | 100 |   1 |
| r13b r13w r13d r13 | 101 |   1 |
| r14b r14w r14d r14 | 110 |   1 |
| r15b r15w r15d r15 | 111 |   1 |

#+NAME: gen_x86_reg_bits
#+BEGIN_SRC emacs-lisp :var rt=tbl_x86_reg_bits
  (let ((res))
    (mapcar
     (lambda (row)
       (let ((regs
              (mapcar (lambda (elt) (intern (format ":%%%s" elt)))
                      (split-string (car row))))
             (bits (cadr row))
             (wide (caddr row)))
         (push (format "    (when (one-of-them reg %s)"
                       (mapconcat '(lambda (x) (format "%s" x))
                                  regs " "))
               res)
         (push (format "      %s (list :reg #b%s :rex-w %s)))"
                       "(return-from get-x86-blk" bits wide)
               res)))
     rt)
    (push "   (error \"unknown-register\")" res)
    (print (concat (format "(defun get-x86-reg-bits (reg) \n%s\n%s)"
                           "  (block get-x86-blk"
                           (mapconcat '(lambda (x) (format "%s" x))
                                      (reverse res) "\n"))
                   ")")))
#+END_SRC


Для того чтобы переводить регистры в соответствующии им биты, нужны
следующие процедуры:

#+NAME: get_x86_reg
#+BEGIN_SRC elisp :noweb tangle
  (defmacro one-of-them (var &rest vals)
    (let ((acc))
      (dolist (elt vals)
        (push `(equal ,var ,elt) acc))
      (setq acc (reverse acc))
      (push 'or acc)
      acc))

  ;; (macroexpand '(one-of-them reg :%al :%ax :%eax :%rax))

  (defun int-to-binary-string (i)
    "convert an integer into it's binary representation in string format"
    (let ((res ""))
      (while (not (= i 0))
        (setq res (concat (if (= 1 (logand i 1)) "1" "0") res))
        (setq i (lsh i -1)))
      (if (string= res "")
          (setq res "0"))
      res))

  ;; (int-to-binary-string 6)
#+END_SRC

А для сборки инструкций в конкретные байты - вот такая:

#+NAME: cmd_plist_to_bytes
#+BEGIN_SRC elisp
  (defun cmd-plist-to-bytes (in)
    (let ((acc)
          (rex-plist (getf in :rex))
          (rex #x40))
      ;; rex if needed
      (if (not (null rex-plist))
          (when (getf rex-plist :w)
            (setf rex (logior rex #x8))
            (setf acc (append acc (list rex)))))
      ;; opcode
      (setf acc (append acc (list (getf in :op))))
      ;; modrm
      (let ((modrm 0))
        (setf modrm (ash (getf in :mod) 6))
        (setf modrm (logior modrm (ash (getf in :reg) 3)))
        (setf modrm (logior modrm (getf in :mem)))
        (setf acc (append acc (list modrm))))
      acc))

  ;; (mapcar #'(lambda (in)
  ;;             (format "%X" in))
  ;;         (cmd-plist-to-bytes
  ;;          (cadr (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi))))
#+END_SRC

Также нам понадобится все это собрать

#+NAME: abstract_assembler_cmds
#+BEGIN_SRC elisp :noweb :tangle src/aasm.el :noweb tangle :exports code
  <<get_x86_reg>>
  <<gen_x86_reg_bits(tbl_x86_reg_bits)>>
  <<mov_reg_to_reg_x86_64>>
  <<push_and_pop_reg_x86_64>>
#+END_SRC

*** DONE mov_reg_to_reg_x86_64

Prefix
- RAX - если нужен
- 0x66 - [TODO:gmm] префикс изменения размера операнда
Opcode:
- 89/r - MOV reg/mem64, reg64 - Move the contents of a 64-bit register to
  a 64-bit destination register or memory operand
- 8B/r - MOV reg64, reg/mem64 - Move the contents of a 64-bit register or
  memory operand to a 64-bit destination register.

ModR/M - [mod:7:6][reg:5:3][r/m:2:0]
mod = 11b - register-direct-addressing mode
reg: register
mem: register

#+NAME: mov_reg_to_reg_x86_64
#+BEGIN_SRC elisp
  (defun get-cmd-plist-x86--mov-reg-to-reg (from to)
    (let ((reg1  (get-x86-reg-bits from))
          (reg2  (get-x86-reg-bits to))
          (rex   nil))
      (cond ((and (getf reg1 :rex-w)
                  (getf reg2 :rex-w))
             (progn
               (setf (getf rex :w) t)
               (setf reg1 (getf reg1 :reg))
               (setf reg2 (getf reg2 :reg))))
            ((and (null (getf reg1 :rex-w))
                  (null (getf reg2 :rex-w)))
             (progn (setf reg1 (getf reg1 :reg))
                    (setf reg2 (getf reg2 :reg))))
            (t (let ((errstr (format "rex-w mismatch %s %s" from to)))
                 (print errstr)
                 (error "ERR: rex-w mismatch"))))
      (values
       `(:rex ,rex :op #x89 :mod #b11 :reg ,reg1 :mem ,reg2)
       `(:rex ,rex :op #x8B :mod #b11 :reg ,reg2 :mem ,reg1))))

  ;; (get-cmd-plist-x86--mov-reg-to-reg :%esi :%edi)
  ;; (get-cmd-plist-x86--mov-reg-to-reg :%rsi :%rdi)

#+END_SRC

*** DONE push_and_pop_reg_x86_64

For the first 8 registers push/pop reg is a 1 byte command. Byte value is obtained
from the expression op + reg where op is 0x50 for push and
0x58 for pop. Reg value can be found in the table above.

#+NAME: push_and_pop_reg_x86_64
#+BEGIN_SRC elisp
  (defun cmd-short-plist-to-bytes (in)
    (list (logior (ash (getf in :op) 3)
                  (getf in :reg))))

  (defun get-cmd-plist-x86--push-reg (source)
    (let ((reg (getf (get-x86-reg-bits source) :reg)))
      (values `(:op #x0A :reg ,reg))))

  ;; (get-cmd-plist-x86--push-reg :%esi)

  (defun get-cmd-plist-x86--pop-reg (target)
    (let ((reg (getf (get-x86-reg-bits target) :reg)))
      (values `(:op #x0B :reg ,reg))))

  ;; (get-cmd-plist-x86--pop-reg :%esi)

  ;; (mapcar #'(lambda (in)
  ;;             (format "%X" in))
  ;;         (cmd-short-plist-to-bytes
  ;;          (car (get-cmd-plist-x86--pop-reg :%esi))))
#+END_SRC

*** TODO jmp_reg_x86_64

[TODO:kvt] description

https://www.felixcloutier.com/x86/jmp

FF /4

/4 means that field reg in mod-reg-rm contains 4 (100b)
mod contains 00b for indirect jumps and 11b for direct jumps
FF E0 ; jmp eax - E0 is 11 100 000 in binary
                        ^  ^   ^
                        |  |   +- 000 is eax
                        |  +- 100 is 4 from /4
                        +- 11 is direct addressing
FF 20 ; jmp [eax] - indirect jump

EB cb Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits

https://www.cyberforum.ru/asm-beginners/thread927866.html

В случае косвенного перехода jmp в поле reg байта ModR/m
хранится продолжение команды. Когда jmp ближний, там
хранится 4, когда дальний - 5. Т.е. команда дальнего
косвенного перехода выглядит так: 1111 1111 10 1---, где
поле Mod, всегда равен 00, потому что байта Sib в команде
jmp быть не может; а --- поле R/m, которое равно либо коду
регистра, если в команде он фигурирует, либо 101, если после
байта ModR/m идут байты смещения. Так вот, в случае ближнего
перехода Интел допускает хранение адреса перехода и в
регистре, и в памяти. В вашем примере JMP [BX] - адрес
хранится в регистре. В случае же дальнего перехода Интел
допускает хранение адреса только в памяти, поэтому тупое
добавление 8 к предыдущей команде, оно же попытка
сформировать JMP FAR [BX] - это ошибка и есть, процессор
этого не понимает.

#+NAME: jmp_reg_x86_64
#+BEGIN_SRC elisp

    (defun get-cmd-plist-x86--jmp-reg-direct (target)
      (let ((mem (getf (get-x86-reg-bits target) :reg)))
        (values `(:op #xFF :mod 3 :reg 4 :mem ,mem))))

    (defun get-cmd-plist-x86--jmp-reg-indirect (target)
      (let ((mem (getf (get-x86-reg-bits target) :reg)))
        (values `(:op #xFF :mod 0 :reg 4 :mem ,mem))))

    ;; (get-cmd-plist-x86--jmp-reg-direct :%eax)

    ;; (mapcar #'(lambda (in)
    ;;             (format "%X" in))
    ;;         (cmd-plist-to-bytes
    ;;          (car (get-cmd-plist-x86--jmp-reg-indirect :%eax))))

  (defun get-cmd-plist-x86--jmp-relative-short (offset)
    (values `(:op #xEB :offset ,offset))
    )

  (get-cmd-plist-x86--jmp-relative-short #x5F)

  (defun cmd-short-jmp-plist-to-bytes (in)
    (list (getf in :op) (getf in :offset))
    )

   ;; (mapcar #'(lambda (in)
   ;;             (format "%X" in))
   ;;         (cmd-short-jmp-plist-to-bytes
   ;;          (car (get-cmd-plist-x86--jmp-relative-short #x5F))))


#+END_SRC

*** TODO je_x86_64
* START Macro processing

Мы часто будем использовать макросы, такие как NEXT:

#+NAME: macro_next
#+BEGIN_EXAMPLE asm
  .set _WZ_, 0x08

  .macro NEXT
      mov     %IRP, %ACR
      add     $_WZ_, %IRP
      jmp     *(%ACR)
  .endm
#+END_EXAMPLE

#+BEGIN_SRC elisp :var arg=macro_next :results value list pp
  (mapcar #'(lambda (in) (princ "\n") (prin1 in))
          (mapcar #'p-aasm
                  (split-string arg "\n" nil nil)))
#+END_SRC

#+results:
: - ((set-const :const "_WZ_" :val "0x08" :rest nil :ident 0)
: - (:empty)
: - (macro :name "NEXT" :rest "" :ident 0)
: - (mov_reg_to_reg :from "%IRP" :to "%ACR" :rest "" :ident 4)
: - (add_const_to_reg :const "$_WZ_" :to "%IRP" :rest nil :ident 4)
: - (jmp_reg_indirect :to "%ACR" :rest "" :ident 4)
: - (endm :rest nil :ident 0)
: - (:empty))

* TODO Elf maker
* TODO Disassembler
